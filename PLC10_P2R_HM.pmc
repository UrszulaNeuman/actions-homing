CLOSE

//#################################################################
// Autogenerated Homing PLC for PowerBrick, DO NOT MODIFY
// Group 2:
// ;  Axis 1: htype = RLIM, jdist = -1000, post = None
// Group 3:
// ;  Axis 2: htype = HSW, jdist = -1000, post = None
// Group 4:
// ;  Axis 3: htype = HSW, jdist = -1000, post = None
//
// Manual homing instructions:
// Run homing for group GROUP_NUM: P1002 = GROUP_NUM enable PLC10
// Run homing: enable PLC10
// Run homing in debug mode: P1001 = 9 enable PLC10
// Pause homing: P1001 = 8
// Abort homing: P1001 = 2
// See definitions below to understand the status and the state.
//#################################################################


// Homing State P Variable
#define PLC10_HomingState       P1000
#define PLC10_StateIdle         0
#define PLC10_StateConfiguring  1
#define PLC10_StateMoveNeg      2
#define PLC10_StateMovePos      3
#define PLC10_StateHoming       4
#define PLC10_StatePostHomeMove 5
#define PLC10_StateAligning     6
#define PLC10_StateDone         7
#define PLC10_StateFastSearch   8
#define PLC10_StateFastRetrace  9
#define PLC10_StatePreHomeMove  10
PLC10_HomingState = PLC10_StateIdle

// Homing Status P Variable
#define PLC10_HomingStatus      P1001
#define PLC10_StatusDone        0
#define PLC10_StatusHoming      1
#define PLC10_StatusAborted     2
#define PLC10_StatusTimeout     3
#define PLC10_StatusFFErr       4
#define PLC10_StatusLimit       5
#define PLC10_StatusIncomplete  6
#define PLC10_StatusInvalid     7
#define PLC10_StatusPaused      8
#define PLC10_StatusDebugHoming 9
PLC10_HomingStatus = PLC10_StatusDone

// Homing Group P Variable
#define PLC10_HomingGroup       P1002
PLC10_HomingGroup = 0

// Homing Group Backup P Variable
#define PLC10_HomingBackupGroup P1003
PLC10_HomingBackupGroup = 0

open plc 10 

if (PLC10_HomingStatus != PLC10_StatusHoming && PLC10_HomingStatus != PLC10_StatusDebugHoming){
    PLC10_HomingStatus = PLC10_StatusHoming
}

//---- Configuring State ----
PLC10_HomingState=PLC10_StateConfiguring
//Save the Homing group to px03
PLC10_HomingBackupGroup=PLC10_HomingGroup
//Save high soft limits to P variables px04..x19
P1004=Motor[1].MaxPos P1005=Motor[2].MaxPos P1006=Motor[3].MaxPos
//Save the low soft limits to P variables px20..x35
P1020=Motor[1].MinPos P1021=Motor[2].MinPos P1022=Motor[3].MinPos
//Save the home capture flags to P variables px36..x51
P1036=Gate3[0].Chan[0].CaptCtrl P1037=Gate3[0].Chan[1].CaptCtrl P1038=Gate3[0].Chan[2].CaptCtrl
//Store 'not flag' to use in moving off a flag in P variables px52..x67
P1052=P1036^12 P1053=P1037^12 P1054=P1038^12
//Save the limit flags to P variables px68..x83
P1068=Motor[1].pLimits P1069=Motor[2].pLimits P1070=Motor[3].pLimits
//Save the current position to P variables px84..x99
P1084=Motor[1].Pos - Motor[1].HomePos P1085=Motor[2].Pos - Motor[2].HomePos P1086=Motor[3].Pos - Motor[3].HomePos
//Clear the soft limits
Motor[1].MaxPos=0 Motor[2].MaxPos=0 Motor[3].MaxPos=0
Motor[1].MinPos=0 Motor[2].MinPos=0 Motor[3].MinPos=0

if ((PLC10_HomingBackupGroup == 1 || PLC10_HomingBackupGroup == 2) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming)){
    PLC10_HomingGroup=2

    //Clear home flags
    // Can't clear home on PBRICK
    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- PreHomeMove State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StatePreHomeMove
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastSearch State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastSearch
        // Execute the move commands
        Motor[1].ProgJogPos=100000000*(Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Store the difference between current pos and start pos ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        P1084=(P1084 - (Motor[1].Pos - Motor[1].HomePos)) + -1000 - Motor[1].HomeOffset
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastRetrace State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastRetrace
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1052 Motor[1].ProgJogPos=100000000*(-Motor[1].HomeVel/ABS(Motor[1].HomeVel))
        jog1^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- Homing State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateHoming
        // Execute the move commands
        Gate3[0].Chan[0].CaptCtrl=P1036
        home1
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[1].InPos == 0 ) && (Motor[1].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[1].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Check if all motors have homed ----
    if ((PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) &&(Motor[1].HomeComplete == 0 )){
        PLC10_HomingStatus=PLC10_StatusIncomplete
    }

}

if ((PLC10_HomingBackupGroup == 1 || PLC10_HomingBackupGroup == 3) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming)){
    PLC10_HomingGroup=3

    //Clear home flags
    // Can't clear home on PBRICK
    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- PreHomeMove State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StatePreHomeMove
        // Execute the move commands
        Motor[2].ProgJogPos=100000000*(-Motor[2].HomeVel/ABS(Motor[2].HomeVel))
        jog2^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[2].InPos == 0 ) && (Motor[2].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[2].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastSearch State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastSearch
        // Execute the move commands
        Motor[2].ProgJogPos=100000000*(Motor[2].HomeVel/ABS(Motor[2].HomeVel))
        jog2^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[2].InPos == 0 ) && (Motor[2].FeFatal == 0 ) && (Motor[2].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[2].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[2].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Store the difference between current pos and start pos ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        P1085=(P1085 - (Motor[2].Pos - Motor[2].HomePos)) + -1000 - Motor[2].HomeOffset
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastRetrace State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastRetrace
        // Execute the move commands
        Gate3[0].Chan[1].CaptCtrl=P1053 Motor[2].ProgJogPos=100000000*(-Motor[2].HomeVel/ABS(Motor[2].HomeVel))
        jog2^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[2].InPos == 0 ) && (Motor[2].FeFatal == 0 ) && (Motor[2].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[2].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[2].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- Homing State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateHoming
        // Execute the move commands
        Gate3[0].Chan[1].CaptCtrl=P1037
        home2
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[2].InPos == 0 ) && (Motor[2].FeFatal == 0 ) && (Motor[2].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[2].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[2].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Check if all motors have homed ----
    if ((PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) &&(Motor[2].HomeComplete == 0 )){
        PLC10_HomingStatus=PLC10_StatusIncomplete
    }

}

if ((PLC10_HomingBackupGroup == 1 || PLC10_HomingBackupGroup == 4) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming)){
    PLC10_HomingGroup=4

    //Clear home flags
    // Can't clear home on PBRICK
    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- PreHomeMove State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StatePreHomeMove
        // Execute the move commands
        Motor[3].ProgJogPos=100000000*(-Motor[3].HomeVel/ABS(Motor[3].HomeVel))
        jog3^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[3].InPos == 0 ) && (Motor[3].FeFatal == 0 )&& (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[3].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastSearch State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastSearch
        // Execute the move commands
        Motor[3].ProgJogPos=100000000*(Motor[3].HomeVel/ABS(Motor[3].HomeVel))
        jog3^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[3].InPos == 0 ) && (Motor[3].FeFatal == 0 ) && (Motor[3].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[3].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[3].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Store the difference between current pos and start pos ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        P1086=(P1086 - (Motor[3].Pos - Motor[3].HomePos)) + -1000 - Motor[3].HomeOffset
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- FastRetrace State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateFastRetrace
        // Execute the move commands
        Gate3[0].Chan[2].CaptCtrl=P1054 Motor[3].ProgJogPos=100000000*(-Motor[3].HomeVel/ABS(Motor[3].HomeVel))
        jog3^*^-1000
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[3].InPos == 0 ) && (Motor[3].FeFatal == 0 ) && (Motor[3].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[3].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[3].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    // Wait for user to tell us to continue if in debug
    if (PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingStatus = PLC10_StatusPaused
        while (PLC10_HomingStatus == PLC10_StatusPaused){}
    }

    //---- Homing State ----
    if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
        PLC10_HomingState=PLC10_StateHoming
        // Execute the move commands
        Gate3[0].Chan[2].CaptCtrl=P1038
        home3
        // Wait for the move to complete
        CALL DelayTimer.msec(5)
        Sys.CdTimer[10]=600000
        while ((Motor[3].InPos == 0 ) && (Motor[3].FeFatal == 0 ) && (Motor[3].LimitStop == 0 ) && (Sys.CdTimer[10] > 0) && (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) ){
        }
        // Check why we left the while loop
        if (Motor[3].FeFatal != 0 ){ // Following error check failed
            PLC10_HomingStatus = PLC10_StatusFFErr
        }
        if (Motor[3].LimitStop != 0 ){ // Limit check failed
            PLC10_HomingStatus = PLC10_StatusLimit
        }
        if (Sys.CdTimer[10]<=0 ){ // If we timed out
            PLC10_HomingStatus = PLC10_StatusTimeout
        }
    }

    //---- Check if all motors have homed ----
    if ((PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming) &&(Motor[3].HomeComplete == 0 )){
        PLC10_HomingStatus=PLC10_StatusIncomplete
    }

}

//---- Done ----
if (PLC10_HomingStatus == PLC10_StatusHoming || PLC10_HomingStatus == PLC10_StatusDebugHoming){
    //If we've got this far without failing, set status and state done
    PLC10_HomingStatus=PLC10_StatusDone
    PLC10_HomingState=PLC10_StateDone
    //Restore the homing group from px03
    PLC10_HomingGroup=PLC10_HomingBackupGroup
}

//---- Tidy Up ----
//Stop all motors if they don't have a following error
if (Motor[1].FeFatal == 0){
    jog/1
}
if (Motor[2].FeFatal == 0){
    jog/2
}
if (Motor[3].FeFatal == 0){
    jog/3
}
//Restore the high soft limits from P variables px04..x19
Motor[1].MaxPos=P1004 Motor[2].MaxPos=P1005 Motor[3].MaxPos=P1006
//Restore the low soft limits from P variables px20..x35
Motor[1].MinPos=P1020 Motor[2].MinPos=P1021 Motor[3].MinPos=P1022
//Restore the home capture flags from P variables px36..x51
Gate3[0].Chan[0].CaptCtrl=P1036 Gate3[0].Chan[1].CaptCtrl=P1037 Gate3[0].Chan[2].CaptCtrl=P1038
//Restore the limit flags to P variables px68..x83
Motor[1].pLimits=P1068 Motor[2].pLimits=P1069 Motor[3].pLimits=P1070

disable plc 10
close
